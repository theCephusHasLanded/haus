{"ast":null,"code":"'use client';\n\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  assignRef: () => assignRef,\n  mergeRefs: () => mergeRefs,\n  useMergeRefs: () => useMergeRefs\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_react = require(\"react\");\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n  if (typeof ref === \"function\") {\n    ref(value);\n    return;\n  }\n  try {\n    ref.current = value;\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);\n  }\n}\nfunction mergeRefs(...refs) {\n  return node => {\n    refs.forEach(ref => {\n      assignRef(ref, node);\n    });\n  };\n}\nfunction useMergeRefs(...refs) {\n  return (0, import_react.useMemo)(() => mergeRefs(...refs), refs);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  assignRef,\n  mergeRefs,\n  useMergeRefs\n});","map":{"version":3,"names":["src_exports","__export","assignRef","mergeRefs","useMergeRefs","module","exports","__toCommonJS","import_react","require","ref","value","current","error","Error","refs","node","forEach","useMemo"],"sources":["../src/index.ts"],"sourcesContent":["import { useMemo } from \"react\"\n\nexport type ReactRef<T> = React.RefCallback<T> | React.MutableRefObject<T>\n\nexport function assignRef<T = any>(\n  ref: ReactRef<T> | null | undefined,\n  value: T,\n) {\n  if (ref == null) return\n\n  if (typeof ref === \"function\") {\n    ref(value)\n    return\n  }\n\n  try {\n    ref.current = value\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\nexport function mergeRefs<T>(...refs: (ReactRef<T> | null | undefined)[]) {\n  return (node: T | null) => {\n    refs.forEach((ref) => {\n      assignRef(ref, node)\n    })\n  }\n}\n\nexport function useMergeRefs<T>(...refs: (ReactRef<T> | null | undefined)[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => mergeRefs(...refs), refs)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA;AAAAC,QAAA,CAAAD,WAAA;EAAAE,SAAA,EAAAA,CAAA,KAAAA,SAAA;EAAAC,SAAA,EAAAA,CAAA,KAAAA,SAAA;EAAAC,YAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAAP,WAAA;AAAA,IAAAQ,YAAA,GAAwBC,OAAA;AAIjB,SAASP,UACdQ,GAAA,EACAC,KAAA,EACA;EACA,IAAID,GAAA,IAAO,MAAM;EAEjB,IAAI,OAAOA,GAAA,KAAQ,YAAY;IAC7BA,GAAA,CAAIC,KAAK;IACT;EACF;EAEA,IAAI;IACFD,GAAA,CAAIE,OAAA,GAAUD,KAAA;EAChB,SAASE,KAAA,EAAP;IACA,MAAM,IAAIC,KAAA,CAAM,wBAAwBH,KAAA,aAAkBD,GAAA,GAAM;EAClE;AACF;AAEO,SAASP,UAAA,GAAgBY,IAAA,EAA0C;EACxE,OAAQC,IAAA,IAAmB;IACzBD,IAAA,CAAKE,OAAA,CAASP,GAAA,IAAQ;MACpBR,SAAA,CAAUQ,GAAA,EAAKM,IAAI;IACrB,CAAC;EACH;AACF;AAEO,SAASZ,aAAA,GAAmBW,IAAA,EAA0C;EAE3E,WAAOP,YAAA,CAAAU,OAAA,EAAQ,MAAMf,SAAA,CAAU,GAAGY,IAAI,GAAGA,IAAI;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"script"}