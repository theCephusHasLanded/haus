{"ast":null,"code":"'use client';\n\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  useCounter: () => useCounter\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/use-counter.ts\nvar import_react_use_callback_ref = require(\"@chakra-ui/react-use-callback-ref\");\nvar import_number_utils = require(\"@chakra-ui/number-utils\");\nvar import_react = require(\"react\");\nfunction useCounter(props = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    keepWithinRange = true\n  } = props;\n  const onChangeProp = (0, import_react_use_callback_ref.useCallbackRef)(onChange);\n  const [valueState, setValue] = (0, import_react.useState)(() => {\n    var _a;\n    if (defaultValue == null) return \"\";\n    return (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : \"\";\n  });\n  const isControlled = typeof valueProp !== \"undefined\";\n  const value = isControlled ? valueProp : valueState;\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  const precision = precisionProp != null ? precisionProp : decimalPlaces;\n  const update = (0, import_react.useCallback)(next => {\n    if (next === value) return;\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]);\n  const clamp = (0, import_react.useCallback)(value2 => {\n    let nextValue = value2;\n    if (keepWithinRange) {\n      nextValue = (0, import_number_utils.clampValue)(nextValue, min, max);\n    }\n    return (0, import_number_utils.toPrecision)(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  const increment = (0, import_react.useCallback)((step = stepProp) => {\n    let next;\n    if (value === \"\") {\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const decrement = (0, import_react.useCallback)((step = stepProp) => {\n    let next;\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const reset = (0, import_react.useCallback)(() => {\n    var _a;\n    let next;\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      next = (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : min;\n    }\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  const castValue = (0, import_react.useCallback)(value2 => {\n    var _a;\n    const nextValue = (_a = cast(value2, stepProp, precision)) != null ? _a : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  const valueAsNumber = parse(value);\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  const isAtMax = valueAsNumber === max;\n  const isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\nfunction getDecimalPlaces(value, step) {\n  return Math.max((0, import_number_utils.countDecimalPlaces)(step), (0, import_number_utils.countDecimalPlaces)(value));\n}\nfunction cast(value, step, precision) {\n  const parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return void 0;\n  const decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return (0, import_number_utils.toPrecision)(parsedValue, precision != null ? precision : decimalPlaces);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  useCounter\n});","map":{"version":3,"names":["src_exports","__export","useCounter","module","exports","__toCommonJS","import_react_use_callback_ref","require","import_number_utils","import_react","props","onChange","precision","precisionProp","defaultValue","value","valueProp","step","stepProp","min","Number","MIN_SAFE_INTEGER","max","MAX_SAFE_INTEGER","keepWithinRange","onChangeProp","useCallbackRef","valueState","setValue","useState","_a","cast","isControlled","decimalPlaces","getDecimalPlaces","parse","update","useCallback","next","toString","clamp","value2","nextValue","clampValue","toPrecision","increment","decrement","reset","castValue","valueAsNumber","isOutOfRange","isAtMax","isAtMin","parseFloat","replace","Math","countDecimalPlaces","parsedValue","isNaN"],"sources":["../src/index.ts","../src/use-counter.ts"],"sourcesContent":["export { useCounter } from \"./use-counter\"\nexport type { UseCounterProps, UseCounterReturn } from \"./use-counter\"\n","import { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport {\n  clampValue,\n  countDecimalPlaces,\n  toPrecision,\n} from \"@chakra-ui/number-utils\"\nimport { useCallback, useState } from \"react\"\n\nexport interface UseCounterProps {\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?(valueAsString: string, valueAsNumber: number): void\n  /**\n   * The number of decimal points used to round the value\n   */\n  precision?: number\n  /**\n   * The initial value of the counter. Should be less than `max` and greater than `min`\n   */\n  defaultValue?: string | number\n  /**\n   * The value of the counter. Should be less than `max` and greater than `min`\n   */\n  value?: string | number\n  /**\n   * The step used to increment or decrement the value\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   * @default Number.MIN_SAFE_INTEGER\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  max?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   *  the value will not exceed the `max` or go lower than `min`\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n}\n\nexport function useCounter(props: UseCounterProps = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    keepWithinRange = true,\n  } = props\n\n  const onChangeProp = useCallbackRef(onChange)\n\n  const [valueState, setValue] = useState<string | number>(() => {\n    if (defaultValue == null) return \"\"\n    return cast(defaultValue, stepProp, precisionProp) ?? \"\"\n  })\n\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n  const isControlled = typeof valueProp !== \"undefined\"\n  const value = isControlled ? valueProp : valueState\n\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp)\n\n  const precision = precisionProp ?? decimalPlaces\n\n  const update = useCallback(\n    (next: string | number) => {\n      if (next === value) return\n      if (!isControlled) {\n        setValue(next.toString())\n      }\n      onChangeProp?.(next.toString(), parse(next))\n    },\n    [onChangeProp, isControlled, value],\n  )\n\n  // Function to clamp the value and round it to the precision\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) {\n        nextValue = clampValue(nextValue, min, max)\n      }\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = stepProp) => {\n      let next: string | number\n\n      /**\n       * Let's follow the native browser behavior for\n       * scenarios where the input starts empty (\"\")\n       */\n      if (value === \"\") {\n        /**\n         * If `min` is set, native input, starts at the `min`.\n         * Else, it starts at `step`\n         */\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = stepProp) => {\n      let next: string | number\n\n      // Same thing here. We'll follow native implementation\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: string | number\n    if (defaultValue == null) {\n      next = \"\"\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp) ?? min\n    }\n    update(next)\n  }, [defaultValue, precisionProp, stepProp, update, min])\n\n  const castValue = useCallback(\n    (value: string | number) => {\n      const nextValue = cast(value, stepProp, precision) ?? min\n      update(nextValue)\n    },\n    [precision, stepProp, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  /**\n   * Common range checks\n   */\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min\n  const isAtMax = valueAsNumber === max\n  const isAtMin = valueAsNumber === min\n\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nfunction parse(value: string | number) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n}\n\nfunction getDecimalPlaces(value: number, step: number) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value))\n}\n\nfunction cast(value: string | number, step: number, precision?: number) {\n  const parsedValue = parse(value)\n  if (Number.isNaN(parsedValue)) return undefined\n  const decimalPlaces = getDecimalPlaces(parsedValue, step)\n  return toPrecision(parsedValue, precision ?? decimalPlaces)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}